(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{354:function(e,t,v){"use strict";v.r(t);var _=v(12),a=Object(_.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"vue生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue生命周期"}},[e._v("#")]),e._v(" vue生命周期")]),e._v(" "),t("h2",{attrs:{id:"_1、面试题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、面试题"}},[e._v("#")]),e._v(" 1、面试题")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("vue生命周期是什么？作用是什么？")]),e._v(" "),t("p",[e._v("vue实例从创建到销毁的过程为生命周期，从开始创建、初始化数据、编译模版、挂载dom->渲染、更新->渲染、卸载等一系列过程称之为vue的生命周期。在控制整个vue实例的过程中更容易形成好的逻辑。")])]),e._v(" "),t("li",[t("p",[e._v("vue生命周期总共有几个阶段？")]),e._v(" "),t("p",[e._v("总共分为8个阶段：创建前/后（beforeCreate/created），载入前/后(beforeMount/mounted)，更新前/后(beforeUpdated/updated)，销毁前/后(beforeDestory/destoryed)")])]),e._v(" "),t("li",[t("p",[e._v("第一次页面加载会触发哪些勾子？")]),e._v(" "),t("p",[e._v("会触发beforeCreate，created，beforeMount，mounted这几个钩子")])]),e._v(" "),t("li",[t("p",[e._v("dom渲染在哪个周期中就已经完成了？")]),e._v(" "),t("p",[e._v("DOM渲染在mounted中就已经完成了")])]),e._v(" "),t("li",[t("p",[e._v("简述每个生命周期具体适合场景？")]),e._v(" "),t("ul",[t("li",[e._v("创建vue实例，执行init()，在init过程中首先调用了beforeCreate勾子，同时监听data数据变化，初始化vue内部事件，进行属性和方法的计算，之后执行created函数")]),e._v(" "),t("li",[e._v("模版编译，把data对象里面的数据和vue语法写的模版编译成html，编译过程分为三种情况\n"),t("ul",[t("li",[e._v("实例内部有template属性，直接调用，然后调用render函数去渲染")]),e._v(" "),t("li",[e._v("没有template属性调用外部html")]),e._v(" "),t("li",[e._v("都没有抛出错误")])])]),e._v(" "),t("li",[e._v("编译模版完成，调用beforeMount钩子函数")]),e._v(" "),t("li",[e._v("render函数执行之后，将渲染出来的内容挂载到dom节点上，挂载结束，调用mounted钩子函数")]),e._v(" "),t("li",[e._v("数据发生变化，调用beforeUpdate函数，更新完成调用Updated函数。")]),e._v(" "),t("li",[e._v("beforeDestroy销毁所有观察者、组件及事件监听，destoryed实例销毁")])])]),e._v(" "),t("li",[t("p",[e._v("父子组件的生命周期")]),e._v(" "),t("p",[e._v("父->子->子->父：父组件开始执行到beforeMount然后开始子组件执行，最后时父组件的mounted，若有兄弟组件，兄弟组件依次执行到beforeMount，然后按顺序执行mounted，最后父组件mounted。")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("加载")]),e._v(" "),t("p",[e._v("父beforeCreate>父created>父beforeMount>子beforeCreate>子created>子beforeMount>子mounted>父mounted")])]),e._v(" "),t("li",[t("p",[e._v("更新")]),e._v(" "),t("p",[e._v("父beforeUpdate->子beforeUpdate->子updated->父updated")])]),e._v(" "),t("li",[t("p",[e._v("销毁")]),e._v(" "),t("p",[e._v("父beforeDestroy->子beforeDestroy->子destroyed->父destroyed")])])])])]),e._v(" "),t("h2",{attrs:{id:"_2、常用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、常用"}},[e._v("#")]),e._v(" 2、常用")]),e._v(" "),t("ul",[t("li",[e._v("created：组件渲染前，数据请求，启动定时器等异步操作，太多出现白屏现象。")]),e._v(" "),t("li",[e._v("mounted：组件渲染后，建议使用。之前是服务器渲染阶段，不适合发送请求，客户端发送api放在服务器不会渲染的方法里；请求中可能有操作dom操作，会出现问题，在组件挂载至dom元素后再进行请求更新。")]),e._v(" "),t("li",[e._v("beforeDestory()：收尾操作，比如清楚定时器，数据缓存。")])]),e._v(" "),t("h2",{attrs:{id:"_3、图解生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、图解生命周期"}},[e._v("#")]),e._v(" 3、图解生命周期")]),e._v(" "),t("img",{attrs:{src:"/img/vue-lifecycle.png"}}),e._v(" "),t("h3",{attrs:{id:"_1、实例创建"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、实例创建"}},[e._v("#")]),e._v(" 1、实例创建")]),e._v(" "),t("ul",[t("li",[e._v("beforeCreate：创建实例部分初始化，this指向创建的实例。\n"),t("ul",[t("li",[e._v("只初始化了生命周期函数和默认事件，不能获得DOM节点")]),e._v(" "),t("li",[e._v("数据观察事件机制都未形成，data，computed，watch，methods 上的方法和数据均不能访问")]),e._v(" "),t("li",[e._v("可以在这加个loading事件")])])]),e._v(" "),t("li",[e._v("created：创建实例初始化完成，完成数据(data、props、computed)的初始化导入依赖项。\n"),t("ul",[t("li",[e._v("可访问data、computed、watch、methods 上的方法和数据。")]),e._v(" "),t("li",[e._v("未挂载DOM，若在此阶段进行DOM操作一定要放在Vue.nextTick()的回调函数中。")]),e._v(" "),t("li",[e._v("初始化完成时的事件写在这里，异步请求也适宜在这里调用(请求不宜过多，避免白屏时间太长)。可以在这里结束loading事件，还做一些初始化，实现函数自执行。")])])])]),e._v(" "),t("h3",{attrs:{id:"_2、模版编译"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、模版编译"}},[e._v("#")]),e._v(" 2、模版编译")]),e._v(" "),t("ul",[t("li",[e._v("beforeMount：挂载前，虽然得不到具体的DOM元素，但vue挂载的根节点已经创建\n"),t("ul",[t("li",[e._v("beforeMount这个阶段是过渡性的，一般一个项目只能用到一两次。")])])]),e._v(" "),t("li",[e._v("mounted：挂载完成，完成创建vm.$el和双向绑定，完成挂载DOM和渲染，\n"),t("ul",[t("li",[e._v("可在mounted钩子函数中对挂载的DOM进行操作。")]),e._v(" "),t("li",[e._v("可在这发起后端请求，拿回数据，配合路由钩子做一些事情。")])])])]),e._v(" "),t("h3",{attrs:{id:"_3、数据更新"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、数据更新"}},[e._v("#")]),e._v(" 3、数据更新")]),e._v(" "),t("ul",[t("li",[e._v("beforeUpdate：数据更新前，数据驱动DOM。\n"),t("ul",[t("li",[e._v("在数据更新后虽然没有立即更新数据，但是DOM中的数据会改变，这是vue双向数据绑定的作用。")]),e._v(" "),t("li",[e._v("可在更新前访问现有的DOM，如手动移出添加的事件监听器。")])])]),e._v(" "),t("li",[e._v("updated：数据更新后，完成虚拟DOM的重新渲染和打补丁。\n"),t("ul",[t("li",[e._v("组件DOM已完成更新，可执行依赖的DOM操作。注意：不要在此函数中操作数据(修改属性)，会陷入死循环。")])])])]),e._v(" "),t("h3",{attrs:{id:"_4、数据销毁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4、数据销毁"}},[e._v("#")]),e._v(" 4、数据销毁")]),e._v(" "),t("ul",[t("li",[e._v("beforeDestroy：销毁前，可做一些删除提示，如：您确定删除xx吗？")]),e._v(" "),t("li",[e._v("destroyed：销毁后，当前组件已被删除，销毁监听事件，组件、事件、子实例也被销毁。这时组件已经没有了，无法操作里面的任何东西了。")])]),e._v(" "),t("h3",{attrs:{id:"_5、路由缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5、路由缓存"}},[e._v("#")]),e._v(" 5、路由缓存")]),e._v(" "),t("p",[e._v("for keep-alive，组件被激活和销毁时使用。")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("activated：在使用vue-router时有时需要使用来缓存组件状态，这个时候created钩子就不会被重复用了。如果我们的子组件需要在每次加载的时候进行某些操作，可以使用activated钩子触发。")])]),e._v(" "),t("li",[t("p",[e._v("deactivated：组件被移除时使用。")])])]),e._v(" "),t("h3",{attrs:{id:"_6、vue中内置的方法属性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6、vue中内置的方法属性"}},[e._v("#")]),e._v(" 6、vue中内置的方法属性")]),e._v(" "),t("p",[e._v("执行顺序：props => methods =>data => computed => watch。")])])}),[],!1,null,null,null);t.default=a.exports}}]);